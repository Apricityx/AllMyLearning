# 题目整理

## 调度算法

FCFS
![1749989685466](./.操作系统题目整理/1749989685466.png)

![1749990577575](./.操作系统题目整理/1749990577575.png)

SFJ
![1749994176893](./.操作系统题目整理/1749994176893.png)

SRTF
![1749994141363](./.操作系统题目整理/1749994141363.png)

注意点：SFJ分为可抢占式（Preemptive）和非抢占式（Non-preemptive）

## PV原语

📘 题目：打印机共享问题（Multiple Users, One Printer）
🖨️ 场景描述：
某办公室有：

多个员工（线程），需要使用一台共享打印机；

同一时间只能有 一个人使用打印机（互斥访问）；

打印机只能一次打印一份；

如果打印机正在忙，其他人必须排队等候；

每次打印时间不长，但使用频繁。

✅ 要求：
使用 P/V 原语 建模该问题；

写出员工线程的伪代码，确保：

打印操作是互斥的；

所有员工都能公平等待使用打印机；

可以假设打印作业队列是无界的（不考虑作业丢失）。

```c
Employee() {
    P(printer); 
    Print();
    V(printer);
}

```

### Producer-consumer模型

📘 题目：图书馆阅览室问题（Library Reading Room Problem）
📖 场景描述：
一间图书馆阅览室有以下规则：

它有 10 个座位；

多个学生（线程）不断到来，如果有空位就可以坐下阅读；

每个学生进入后，需要从前台服务员那里领取一本书；

阅览室中只有 1 名服务员，同时只能为 1 位学生发书；

如果座位已满，学生不能进入阅览室，必须离开；

阅览完毕的学生将书还给服务员并离开，空出座位。

```c
int seats = 10;
Semaphore enter = 0, mutex = 1, served = 0;

Student(){
    P(mutex);
    if (seats > 0) {
        seats--;
        V(enter);
        get_service();
        P(served);
        V(mutex);
        read();
        P(mutex);
        seats++;
        V(mutex);
        leave();
    } else {
        V(mutex); // 没有座位，离开
    }
}

Service(){
    while (True){
        P(enter);
        service_student();
        V(served);
    }
}

```

### Reader-writer模型

📘 例题：共享打印机日志系统
🖥️ 场景描述：
某公司维护一个打印机日志系统，有多个员工（读者）和管理员（写者）：

员工可以查询打印记录（读操作），多个员工可以同时查询；

管理员可以修改打印日志（写操作），修改时必须独占访问权限；

允许多个员工同时读取，但一旦管理员想修改日志，必须等待所有员工读完；

当管理员正在修改日志时，不允许员工查询；

使用 PV 原语 实现进程同步。

```c
Semaphore write_mutex = 1, mutex = 1;
int read_count = 0;

Employee(){
    P(mutex);
    read_count++;
    if (read_count == 1) {
        P(write_mutex); // 第一个读者阻塞写者
    }
    V(mutex);
    read();
    P(mutex);
    read_count--;
    if (read_count == 0){
        V(write_mutex)
    }
    V(mutex)
}

Administrator(){
    P(write_mutex);
    write();
    V(write_mutex);
}
```

## 银行家算法

📘 例题：打印服务调度系统中的银行家算法应用题

🖥️ 场景背景：

某企业部署了一个**打印服务器资源调度系统**，涉及 **3 种关键资源**：

* A：打印机（台）
* B：扫描仪（个）
* C：传真机（个）

共有：

* 打印机：10 台
* 扫描仪：5 个
* 传真机：7 个

目前有 **4 个用户任务（P0–P3）** 正在使用系统。

---

### 📦 当前资源分配情况如下：

#### Allocation（已分配资源）

| 进程 | A | B | C |
| -- | - | - | - |
| P0 | 0 | 1 | 0 |
| P1 | 2 | 0 | 0 |
| P2 | 3 | 0 | 2 |
| P3 | 2 | 1 | 1 |

#### Max（最大声明资源）

| 进程 | A | B | C |
| -- | - | - | - |
| P0 | 7 | 5 | 3 |
| P1 | 3 | 2 | 2 |
| P2 | 9 | 0 | 2 |
| P3 | 4 | 2 | 2 |

---

### ❓问题一：当前系统是否安全？请给出安全序列。

---

### ❓问题二：

如果此时进程 **P1 请求额外资源** `Request1 = (1, 0, 2)`，请判断：

* 系统是否应该**批准该请求**？
* 如果批准，该请求后是否仍**安全**？
* 如果不批准，请说明原因。

---

## 分页

### 📘【题目】分页地址转换综合题（含 TLB 命中）

**背景：**
某计算机采用分页系统，使用 **32 位虚拟地址**，其中：

* 每页大小为 **4KB**；
* 系统使用 **单级页表**；
* **TLB 命中时间为 1ns**，内存访问时间为 **100ns**；
* 页表存放在内存中。

---

**问题：**

1. 页号（Page Number）和页内偏移（Offset）分别占多少位？
2. 若 TLB 命中率为 95%，求 **有效访问时间（Effective Memory Access Time）EMAT**；
3. 若虚拟地址 `0x12345678` 被访问，请问：

   * 页号是多少？
   * 页内偏移是多少？
   * 如果页表中将其映射到帧号 `0x9AB`，那么物理地址是多少？

## 缺页

### 📘【题目】FIFO 页面置换算法模拟

操作系统采用 **FIFO（先进先出）页面置换算法**进行内存管理。
系统可用的**物理页框数为 3**，现有如下页面访问序列：

页面访问序列：7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2

---

### **问题：**

1. 画出页面状态变化表；
2. 计算 **总缺页次数**；
3. 计算缺页率

好的！以下是一道典型的 **LRU（Least Recently Used）页面置换算法** 模拟题，难度适中，非常适合操作系统复习或考研练习：

---

### 📘【题目】LRU 页面置换算法模拟题

操作系统采用 **LRU 页面置换算法**管理内存。
系统提供 **3 个物理页框**，访问的页面序列如下：

页面访问序列：2, 3, 2, 1, 5, 2, 4, 5, 3, 2, 5, 2

---

### 请回答：

1. 按照 **LRU 算法**画出页面状态变化；
2. 计算总 **缺页次数**；
3. 计算 **缺页率**。

## 二级页表

---

### 📘【Problem】Two-Level Page Table Address Translation

A system uses a **32-bit virtual address** and a **two-level paging scheme**. The system has the following configuration:

* Virtual address: 32 bits
* Page size: 4KB (i.e., 2¹² = 4096 bytes)
* Each page table entry (PTE) is 4 bytes
* Each page directory entry (PDE) is 4 bytes
* A page table or directory fits exactly in one 4KB page
* Therefore: each page table or page directory contains **1024 entries = 2¹⁰ entries**

The virtual address to translate is:

```
VA = 0xCAFEBABE
```

The page directory base register (PDBR) contains:

```
PDBR = 0x00004000
```

The page directory entry at index `0x32F` contains:

```
0x00006003`
```

The page table entry at index `0x2FA` contains:

```
0x00008007`
```

---

### 🧩【Questions】

1. Break the virtual address `0xCAFEBABE` into:

   * Page Directory Index (PDI)
   * Page Table Index (PTI)
   * Page Offset

   (Give values in binary, hex, and decimal)

2. What is the physical address of the page table that corresponds to the PDE at index `0x32F`?

3. What is the physical frame number that corresponds to the PTE at index `0x2FA`?

4. What is the final physical address that the virtual address `0xCAFEBABE` maps to? Show full calculation.

---

## Disk

## 🎯【磁盘调度计算题】

### 题目：

假设磁头当前位于柱面 **53**，等待访问的磁道请求队列如下（单位：柱面号）：

```
98, 183, 37, 122, 14, 124, 65, 67
```

磁盘共有柱面号 `0 ~ 199`。

请分别计算以下调度算法下的**总寻道长度**（即磁头总共移动的柱面数）：

1. **FCFS（先来先服务）**
2. **SSTF（最短寻道时间优先）**
3. **SCAN（电梯算法，磁头初始向右）**
4. **C-LOOK（循环LOOK，磁头初始向右）**

---

## ✅ 解答步骤说明

我们将一一计算这四种调度算法的总寻道长度：

---

### ✳️ 初始状态

* 初始磁头位置：**53**
* 请求队列：**98, 183, 37, 122, 14, 124, 65, 67**

我们将保留原始顺序用于 FCFS；对其他算法，我们进行排序或策略处理。

---

### 🟩 1. FCFS（First Come First Serve）

**原始顺序处理请求：**

```
53 → 98 → 183 → 37 → 122 → 14 → 124 → 65 → 67
```

**逐步寻道距离：**

```
|98 - 53| = 45  
|183 - 98| = 85  
|37 - 183| = 146  
|122 - 37| = 85  
|14 - 122| = 108  
|124 - 14| = 110  
|65 - 124| = 59  
|67 - 65| = 2  
---------------------
Total = 45 + 85 + 146 + 85 + 108 + 110 + 59 + 2 = ✅ 640
```

---

### 🟨 2. SSTF（Shortest Seek Time First）

每次选择**离当前磁道最近的请求**：

* 初始位置：53
* 剩余队列：\[98, 183, 37, 122, 14, 124, 65, 67]

**步骤如下：**

| 当前磁头    | 最近请求 | 移动距离                             | 说明         |
| ------- | ---- | -------------------------------- | ---------- |
| 53      | 65   | 12                               | 65 比 67 更近 |
| 65      | 67   | 2                                |            |
| 67      | 98   | 31                               |            |
| 98      | 122  | 24                               |            |
| 122     | 124  | 2                                |            |
| 124     | 183  | 59                               |            |
| 183     | 37   | 146                              |            |
| 37      | 14   | 23                               |            |
| ✅ Total |      | ✅ 12+2+31+24+2+59+146+23 = ✅ 299 |            |

---

### 🟦 3. SCAN（电梯算法，初始向右）

先向\*\*右（升序）\*\*方向移动，访问大于等于当前柱面的请求，然后调头向左处理小的请求。

**排序后的请求队列：**

```
14, 37, 65, 67, 98, 122, 124, 183
```

当前磁头：53 ⇒ 向右 ⇒ 访问：65 → 67 → 98 → 122 → 124 → 183 → 再调头访问：37 → 14

**实际路径：**

```
53 → 65 → 67 → 98 → 122 → 124 → 183 → 37 → 14
```

**距离合计：**

```
|65 - 53| = 12  
|67 - 65| = 2  
|98 - 67| = 31  
|122 - 98| = 24  
|124 - 122| = 2  
|183 - 124| = 59  
|37 - 183| = 146  
|14 - 37| = 23  
---------------------
Total = ✅ 12 + 2 + 31 + 24 + 2 + 59 + 146 + 23 = ✅ 299
```

⚠️ 注意：在 SCAN 中磁头访问到了末尾 **183** 后再返回处理较小的请求。

---

### 🟪 4. C-LOOK（循环 LOOK，初始向右）

也是向右，但**不访问尽头柱面**（如 199），而是访问最大请求后，**直接跳回最小请求**（非顺序返回）。

访问顺序：

```
53 → 65 → 67 → 98 → 122 → 124 → 183 → [跳回] → 14 → 37
```

**距离合计：**

```
|65 - 53| = 12  
|67 - 65| = 2  
|98 - 67| = 31  
|122 - 98| = 24  
|124 - 122| = 2  
|183 - 124| = 59  
[跳转不计寻道]  
|14 - 183| = 169  
|37 - 14| = 23  
---------------------
Total = ✅ 12 + 2 + 31 + 24 + 2 + 59 + 169 + 23 = ✅ 322
```

---

## ✅ 最终汇总表：

| 调度算法   | 总寻道长度（柱面数） |
| ------ | ---------- |
| FCFS   | 640        |
| SSTF   | 299        |
| SCAN   | 299        |
| C-LOOK | 322        |

---
