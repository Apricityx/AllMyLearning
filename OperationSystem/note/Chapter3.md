# 进程同步与通信

## 竞争条件

## 避免竞争条件

临界区：设计来避免多个线程同时访问某一个变量并进行读写操作时出现问题

例如
```C
int count = 0;
void *thread1(void *arg) {
    for (int i = 0; i < 1000000; i++) {
        count++;
    }
}
void *thread2(void *arg) {
    for (int i = 0; i < 1000000; i++) {
        count--;
    }
}
```

如果这两个线程同时执行，最终count的值可能不确定

为避免这种情况，引入互斥锁

## Peterson算法

Peterson算法维护两个变量：flag[n]和turn

flag作为一个数组，取值为true或false，表示第i个线程是否希望进入临界区

turn表示当前允许哪个线程进入临界区

线程创建时即进入循环，直到turn轮到自身或者其他的线程不想进入临界区

Peterson算法的缺点是
1. Peterson算法专为两个线程设计，无法直接扩展到三个或更多线程
2. 

防止竞争条件的算法需要满足以下三个条件：
1. 互斥(Mutual Exclusion)
2. 进展(Progress)
3. 有限等待(Bounded Waiting)


## PV原理

通过信号量（Semaphore）实现对共享资源的互斥访问或协调进程间的执行顺序，常用于解决生产者-消费者、读者-写者等并发问题

设s为信号量，s的值可以是非负整数

P操作：在进入临界区或申请资源前调用，检查信号量的值

Case1：s>0，表示资源可用，信号量值减1，允许进入临界区
Case2：s=0，表示资源不可用，进程进入等待状态，直到信号量值大于0

V操作：在离开临界区或释放资源后调用，增加信号量的值

调用时
Case1: 如果有进程在等待，s=0，唤醒一个等待进程
Case2: 如果没有进程在等待，s>0，信号量值加1



